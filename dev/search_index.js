var documenterSearchIndex = {"docs":
[{"location":"examples/collapse3d.html#Water-collapse-in-3D","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"","category":"section"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"A three dimensional variant of dam-break example.","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"module collapse3d\n\nusing Printf\nimport SmoothedParticles","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"Declare constant parameters","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"##physical\nconst dr = 5.0e-3          #average particle distance (decrease to make finer simulation)\nconst h = 2.0*dr           #size of kernel support\nconst rho0 = 1000.   \t   #fluid density\nconst m = rho0*dr^3        #particle mass\nconst c = 50.0             #numerical speed of sound\nconst g = -9.8*VECZ        #gravitational acceleration\nconst mu = 8.4e-4          #dynamic viscosity of water\nconst nu = 1.0e-4          #pressure stabilization\n\n##geometrical\nconst water_column_width = 0.142\nconst water_column_height = 0.293\nconst box_height = 0.35\nconst box_width = 0.584\nconst box_depth = 0.15\nconst wall_width = 2.5*dr\n\n##temporal\nconst dt = 0.1*h/c\nconst t_end = 0.5\nconst dt_frame = t_end/200\n\n\n##particle types\nconst FLUID = 0.\nconst WALL = 1.","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"Declare variables to be stored in a Particle","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"mutable struct Particle <: AbstractParticle\n\tx::RealVector #position\n\tv::RealVector #velocity\n\ta::RealVector #acceleration\n\tP::Float64 #pressure\n\trho::Float64 #density\n\tDrho::Float64 #rate of density\n\ttype::Float64 #particle_type\n\tParticle(x, type) = new(\n\t\tx, VEC0, VEC0,\n\t\t0.,\n\t\trho0, 0.,\n\t\ttype\n\t)\nend","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"Define geometry and make particles","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"function make_system()\n\tgrid = Grid(dr, :cubic)\n\tbox = Box(0., 0., 0., box_width, box_height, box_depth)\n\tfluid = Box(0., 0., 0., water_column_width, water_column_height, box_depth)\n\twalls = BoundaryLayer(box, grid, wall_width)\n\twalls = Specification(walls, x -> (x[2] < box_height))\n\tdomain = SmoothedParticles.boundarybox(walls)\n\tsys = ParticleSystem(Particle, domain, h)\n\tgenerate_particles!(sys, grid, fluid, x -> Particle(x, FLUID))\n\tgenerate_particles!(sys, grid, walls, x -> Particle(x, WALL))\n\treturn sys\nend","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"Define particle interactions","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"@inbounds function balance_of_mass!(p::Particle, q::Particle, r::Float64)\n\tker = m*rDwendland3(h,r)\n\tp.Drho += ker*(dot(p.x-q.x, p.v-q.v) + 2*nu*(p.rho-q.rho))\nend\n\nfunction find_pressure!(p::Particle)\n\tp.rho += p.Drho*dt\n\tp.Drho = 0.0\n\tp.P = c^2*(p.rho - rho0)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\tif p.type == FLUID\n\t\tker = m*rDwendland3(h,r)\n\t\tp.a += -ker*(p.P/rho + q.P/rho)*(p.x - q.x)\n\t\tp.a += +2*ker*mu/rho0^2*(p.v - q.v)\n\tend\nend\n\nfunction move!(p::Particle)\n\tp.a = VEC0\n\tif p.type == FLUID\n\t\tp.x += dt*p.v\n\tend\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += 0.5*dt*(p.a + g)\n\tend\nend\n\nfunction energy(p::Particle)::Float64\n\tkinetic = 0.5*m*dot(p.v, p.v)\n\tpotential = -m*dot(g, p.x)\n\tinternal =  m*c^2*(rho0/p.rho + log(abs(p.rho0/rho0)) - 2.0)\n\treturn kinetic + potential + internal\nend","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"Put everything into a time loop","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"function main()\n\tsys = make_system()\n\tout = new_pvd_file(\"results/collapse3d\")\n    println(\"# of parts = \", length(sys.particles))\n\t#a modified Verlet scheme\n\t@time for k = 0 : Int64(round(t_end/dt))\n\t#move particles\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, balance_of_mass!)\n\t\tapply!(sys, find_pressure!)\n\t\tapply!(sys, internal_force!)\n\t\tapply!(sys, accelerate!)\n\t\t#save data at selected frames\n\t\tif (k % Int64(round(dt_frame/dt)) == 0)\n\t\t\t@printf(\"t = %.6e\\n\", k*dt)\n\t\t\t@printf(\"E = %.6e\\n\", sum(energy, sys.particles))\n\t\t\t@printf(\"\\n\")\n\t\t\tsave_frame!(out, sys, :v, :P, :rho, :type)\n\t\tend\n\t\t#accelerate\n\t\tapply!(sys, accelerate!)\n\tend\n\tsave_pvd_file(out)\nend ## function main\n\nend ## module","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"","category":"page"},{"location":"examples/collapse3d.html","page":"Water collapse in 3D","title":"Water collapse in 3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/collapse_dry_implicit.html#Water-collapse-(implicit)","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"\t<img src='../assets/collapse_i.png' width=\"50%\" height=\"50%\" alt='missing' /><br>","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"Simulation of a water column, this time using incompressible SPH. This works by first applying all non-pressure forces to find intermeidate velocity mathbfv^*. The pressure-corrected velocity","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"mathbfv = mathbfv^* - fracdelta tvarrho nabla P","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"is found such that mathbfv is a divergence-free vector field. Taking divergence of both sides leads to a poisson problem","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"- Delta P = -fracvarrhodelta t nabla cdot mathbfv^*","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"A homogeneous Dirichlet condition for pressure is prescribed at the boundary. Free surface can be identified using a trick invented by Lee (2008). A parameter is defined","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"lambda = 1 - frac1d nabla cdot mathbfr","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"which is zero inside the fluid but positive on the boundary. Boundary condition can be implemented smoothly by adding a penalty term:","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"- Delta P + C_mathrmfree lambda P = -fracvarrhodelta t nabla cdot mathbfv^*","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"To get a particle approximation, we replace Delta with a Morris operator and nabla cdot with the usual divergence operator. This yields a system with a positive definite matrix.","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"module collapse_dry_implicit\n\nusing Printf\nusing SmoothedParticles\nusing CSV\nusing DataFrames\nusing LinearAlgebra\nusing IterativeSolvers\nusing IncompleteLU\nusing Parameters\nusing Plots","category":"page"},{"location":"examples/collapse_dry_implicit.html#Constant-parameters","page":"Water collapse (implicit)","title":"Constant parameters","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"##kernel functions\nconst kernel = spline23\nconst Dkernel = Dspline23\nconst rDkernel = rDspline23\n\nconst dim = 2\nconst dr = 1.0e-2         # average particle distance (decrease to refine, increase to speed up)\nconst h = 2.8*dr          # size of kernel support\nconst rho = 1000.0        # fluid density\nconst g = -9.8*VECY       # gravitational acceleration\nconst mu = 8.4e-4         # dynamic viscosity\nconst m = dr^dim*rho      # particle mass\nconst C_free = 10.0       # free surface penalty coefficient\nconst v_char = 5.0        # char velocity\n\n##geometry parameters\nconst water_column_width = 1.0\nconst water_column_height = 2.0\nconst box_height = 3.0\nconst box_width = 4.0\nconst nlayers = 3.5\nconst wall_width = nlayers*dr\n\n##temporal parameters\nconst dt = 0.1*h/v_char\nconst t_end = 2.0\nconst dt_frame = max(dt, t_end/200)\n\n##labels for particle types\nconst FLUID = 0.\nconst  WALL = 1.\nconst DUMMY = 2.","category":"page"},{"location":"examples/collapse_dry_implicit.html#Particle-variables","page":"Water collapse (implicit)","title":"Particle variables","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector = VEC0   #position\n\tv::RealVector = VEC0   #velocity\n\tDv::RealVector = VEC0  #acceleration\n\tP::Float64 = 0.0       #pressure\n\tdiv::Float64 = 0.0     #divergence of velocity\n\tL::Float64 = 0.0       #diagonal element of projection matrix\n\tlambda::Float64 = 0.0  #free surface indetifier\n\ttype::Float64          #particle type\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html#Geometry","page":"Water collapse (implicit)","title":"Geometry","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function make_system()\n\tgrid = Grid(dr, :hexagonal)\n\tbox = Rectangle(0., 0., box_width, box_height)\n\tfluid = Rectangle(0., 0., water_column_width, water_column_height)\n\twalls = Specification(BoundaryLayer(box, grid, 1.2*dr), x -> (x[2] < box_height))\n\tdummy = Specification(BoundaryLayer(box, grid, nlayers*dr) - walls, x -> (x[2] < box_height))\n\tsys = ParticleSystem(Particle, fluid + dummy + walls, h)\n\tgenerate_particles!(sys, grid, fluid, x -> Particle(x=x, type=FLUID))\n\tgenerate_particles!(sys, grid, walls, x -> Particle(x=x, type=WALL))\n\tgenerate_particles!(sys, grid, dummy, x -> Particle(x=x, type=DUMMY))\n\tcreate_cell_list!(sys)\n\treturn sys\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html#Particle-interactions","page":"Water collapse (implicit)","title":"Particle interactions","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function initialize!(p::Particle)\n\tif p.type == FLUID\n\t\tp.x += dt*p.v\n\t\tp.v += dt*g\n\tend\n\tp.div = 0.0\n\tp.L = 0.0\n\tp.lambda = 1.0\nend\n\nfunction viscous_force!(p::Particle, q::Particle, r::Float64)\n\tp.Dv += 2.0*m*mu*rDkernel(h,r)/rho^2*(p.v - q.v)\nend\n\nfunction internal_force!(p::Particle, q::Particle, r::Float64)\n\tp.Dv -= m*rDkernel(h,r)*(p.P + q.P)/rho^2*(p.x - q.x)\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += dt*p.Dv\n\tend\n\tp.Dv = VEC0\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html#Functions-to-build-the-linear-system","page":"Water collapse (implicit)","title":"Functions to build the linear system","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function div_L_lambda!(p::Particle, q::Particle, r::Float64)\n\trDk = rDkernel(h,r)\n\tp.div += -SmoothedParticles.dot(p.x - q.x, p.v - q.v)*m*rDk\n\tp.L += -2.0*m/rho*rDk\n\tp.lambda += m/rho*rDk*r^2/dim\nend\n\nfunction projection_matrix(p::Particle, q::Particle, r::Float64)::Float64\n\tif p == q\n\t\tif p.type == FLUID\n\t\t\treturn h^2*p.L + C_free*max(p.lambda, 0.)\n\t\telse\n\t\t\treturn h^2*p.L\n\t\tend\n\tend\n\treturn 2.0*h^2*m/rho*rDkernel(h,r)\nend\n\nfunction projection_vector(p::Particle)::Float64\n\treturn -h^2*p.div/dt\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html#Extract-global-variables","page":"Water collapse (implicit)","title":"Extract global variables","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"Variables of interest are total energy, water column height and wavefront location.","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function energy(p::Particle)::Float64\n\tkinetic = 0.5*m*SmoothedParticles.dot(p.v, p.v)\n\tpotential = -m*SmoothedParticles.dot(g, p.x)\n\treturn kinetic + potential\nend\n\nfunction get_globals(sys::ParticleSystem)::NTuple{3,Float64}\n\tH = 0.0  # height of water column\n\tX = 0.0  # wavefront x-coordinate\n\tE = 0.0  # total energy\n\tfor p in sys.particles\n\t\tif p.type == FLUID\n\t\t\tX = max(X, p.x[1]/water_column_width)\n\t\tend\n\t\tif p.type == FLUID && 2.0 > p.x[1] > h\n\t\t\tH = max(H, p.x[2]/water_column_height)\n\t\tend\n\t\tE += energy(p)\n\tend\n\treturn (X,H,E)\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html#Time-iteration","page":"Water collapse (implicit)","title":"Time iteration","text":"","category":"section"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function main()\n\tsys = make_system()\n\tout = new_pvd_file(\"results/collapse_dry_implicit\")\n\tP = ParticleField(sys, :P)\n\tts = []\n\tXs = []\n\tHs = []\n\t@time for k = 0 : Int64(round(t_end/dt))\n\t\tif (k %  Int64(round(dt_frame/dt)) == 0)\n\t\t\t@printf(\"t = %.6e s \", k*dt)\n\t\t\tprintln(\"(\",round(100*k*dt/t_end),\"% complete)\")\n\t\t\t(X, H, E) = get_globals(sys)\n\t\t\t@printf(\"energy = %.6e J\\n\", E)\n\t\t\t@printf(\"\\n\")\n\t\t\tpush!(Xs, X)\n\t\t\tpush!(Hs, H)\n\t\t\tpush!(ts, k*dt*sqrt(-2*g[2]))\n\t\t\tsave_frame!(out, sys, :v, :P, :type)\n\t\tend\n\t\tapply!(sys, initialize!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, viscous_force!)\n\t\t##assemble linear system and solve for pressure\n\t\tapply!(sys, div_L_lambda!)\n\t\tA = assemble_matrix(sys, projection_matrix)\n\t\tb = assemble_vector(sys, projection_vector)\n\t\ttry\n\t\t\t#P .= A\\b\n\t\t\tP .= cg(A, b)#; Pl = ilu(A; τ = 0.1))\n\t\tcatch\n\t\t\tsave_pvd_file(out)\n\t\t\terror(\"Unable to solve linear system.\")\n\t\tend\n\t\tapply!(sys, internal_force!)\n\t\tapply!(sys, accelerate!)\n\tend\n\tsave_pvd_file(out)\n\tdata = DataFrame(time = ts, X = Xs, H = Hs)\n\tCSV.write(\"results/collapse_dry_implicit/data.csv\", data)\n\t@info \"drawing a plot with results\"\n\tmake_plot()\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"Compare computed results to the book by Violeau.","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"function make_plot()\n\tdata = CSV.read(\"results/collapse_dry_implicit/data.csv\", DataFrame)\n\tX_VIO = CSV.read(\"reference/dambreak_X_Violeau.csv\", DataFrame)\n\tX_KOS = CSV.read(\"reference/dambreak_X_Koshizuka.csv\", DataFrame)\n\tH_VIO = CSV.read(\"reference/dambreak_H_Violeau.csv\", DataFrame)\n\tH_KOS = CSV.read(\"reference/dambreak_H_Koshizuka.csv\", DataFrame)\n\tp1 = plot(data.time, data.X, label = \"SmoothedParticles.jl\", xlims = (0., 3.0))\n\tscatter!(p1, X_VIO.time, X_VIO.X, label = \"Violeau\")\n\tscatter!(p1, X_KOS.time, X_KOS.X, label = \"Koshizuka&Oda\", markershape = :square)\n\tsavefig(p1, \"results/collapse_dry_implicit/dambreak_X.pdf\")\n\tp2 = plot(data.time, data.H, label = \"SmoothedParticles.jl\", xlims = (0., 3.0))\n\tscatter!(p2, H_VIO.time, H_VIO.H, label = \"Violeau\")\n\tscatter!(p2, H_KOS.time, H_KOS.H, label = \"Koshizuka&Oda\", markershape = :square)\n\tsavefig(p2, \"results/collapse_dry_implicit/dambreak_H.pdf\")\nend\n\nend","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"","category":"page"},{"location":"examples/collapse_dry_implicit.html","page":"Water collapse (implicit)","title":"Water collapse (implicit)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/collapse_symplectic.html#Water-collapse-(explicit,-symplectic,-and-reversible)","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"","category":"section"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"\t<img src='../assets/fixpa.png' alt='missing' width=\"50%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Simulation of a water column collapsing under its own weight onto dry bottom. Here we use a symplectic scheme and get a reversible simulation. At the end of the simulation, the velocities are reverted and the simulation goes back to its initial conditions. Despite the reversibility, Boltzmann entropy grows and attains its maximum value just before the velocities are reverted.","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"module collapse_symplectic\n\nusing Printf\nusing SmoothedParticles\nusing Parameters\nusing Plots\nusing DataFrames # to store the csv file\nusing CSV# to store the csv file\ninclude(\"utils/FixPA.jl\")\ninclude(\"utils/entropy.jl\")\nusing .FixPA\nusing .entropy\n\n\n#using ReadVTK  #not implemented\n#using VTKDataIO","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Declare constant parameters","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"##physical\nconst dr = 1.0e-2          # average particle distance (decrease to refine, increase to speed up)\nconst h = 3.0*dr           # kernel radius\nconst rho0 = 1000.   \t   # fluid density\nconst m = rho0*dr^2        # particle mass\nconst g = -9.8*VECY        # gravitational acceleration\nconst mu = 0.0#8.4e-4      # dynamic viscosity of water\n\n##geometrical\nconst water_column_width = 1.0\nconst water_column_height = 2.0\nconst box_height = 3.0\nconst box_width = 4.0\nconst wall_width = 2.5*dr\n\n\n##artificial\nconst c = 50.0             #numerical speed of sound\nconst dr_wall = 0.95*dr\nconst E_wall = 10*norm(g)*water_column_height\nconst eps = 1e-16\n\n##temporal\nconst dt = 0.1*h/c\nconst t_end = 1.0\nconst dt_frame = t_end/100\n\n##particle types\nconst FLUID = 0.\nconst WALL = 1.\n\n@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector #position\n\tv::RealVector = VEC0 #velocity\n\ta::RealVector = VEC0 #acceleration\n\tP::Float64 = 0. #pressure\n\trho::Float64 = 0. #density\n    rho0::Float64 = 0.\n\ttype::Float64 #particle_type\nend","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Define geometry and make particles","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"function make_system()\n\tgrid = Grid(dr, :square)\n\tbox = Rectangle(0., 0., box_width, box_height)\n\tfluid = Rectangle(0., 0., water_column_width, water_column_height)\n\twalls = BoundaryLayer(box, grid, wall_width)\n\t#walls = Specification(walls, x -> (x[2] < box_height))\n\tdomain = Rectangle(-box_width, -box_width, 2*box_width, 3*box_height)\n\tsys = ParticleSystem(Particle, domain, h)\n\tgenerate_particles!(sys, grid, fluid, x -> Particle(x = x, type = FLUID))\n\tgenerate_particles!(sys, grid, walls, x -> Particle(x = x, type = WALL))\n\treturn sys\nend","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Define particle interactions","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"@inbounds function find_rho!(p::Particle, q::Particle, r::Float64)\n    if p.type == FLUID && q.type == FLUID\n\t\tp.rho += m*wendland2(h,r)\n\tend\nend\n\n@inbounds function find_rho0!(p::Particle, q::Particle, r::Float64)\n    if p.type == FLUID && q.type == FLUID\n\t\tp.rho0 += m*wendland2(h,r)\n\tend\nend\n\nfunction find_pressure!(p::Particle)\n\tp.P = c^2*(p.rho - p.rho0)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\tif p.type == FLUID && q.type == FLUID\n\t\tker = m*rDwendland2(h,r)\n\t\tp.a += -ker*(p.P/p.rho^2 + q.P/q.rho^2)*(p.x - q.x)\n\t\t#p.a += +2*ker*mu/rho0^2*(p.v - q.v)\n\telseif p.type == FLUID && q.type == WALL && r < dr_wall\n\t\ts = dr_wall/(r + eps)\n\t\tp.a += -E_wall/(r + eps)^2*(s^2 - s^4)*(p.x - q.x)\n\tend\nend\n\nfunction reset_a!(p::Particle)\n    p.a = zero(RealVector)\nend\n\nfunction reset_rho!(p::Particle)\n    p.rho = 0.0\nend\n\nfunction move!(p::Particle)\n\tif p.type == FLUID\n\t\tp.x = rev_add(p.x, dt*p.v)\n\tend\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v = rev_add(p.v, 0.5*dt*(p.a + g))\n\tend\nend\n\nfunction LJ_potential(p::Particle, q::Particle, r::Float64)::Float64\n\tif q.type == WALL && p.type == FLUID && r < dr_wall\n\t\ts = dr_wall/(r + eps)\n\t\treturn m*E_wall*(0.5s^2 - 0.25s^4 -0.25)\n\telse\n\t\treturn 0.0\n\tend\nend\n\nfunction energy_kinetic(sys::ParticleSystem)::Float64\n\treturn sum(p -> 0.5*m*dot(p.v, p.v), sys.particles)\nend\n\nfunction energy(sys::ParticleSystem, p::Particle)::Float64\n\tkinetic = 0.5*m*dot(p.v, p.v)\n\tinternal =  m*c^2*(rho0/p.rho + log(abs(p.rho0/rho0)) - 2.0)\n\tgravity_potential = -m*dot(g, p.x)\n\twall_potential = SmoothedParticles.sum(sys, LJ_potential, p)\n\treturn kinetic + internal + gravity_potential + wall_potential\nend","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Put everything into a time loop","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"function verlet_step!(sys::ParticleSystem)\n    apply!(sys, accelerate!)\n    apply!(sys, move!)\n    create_cell_list!(sys)\n    apply!(sys, reset_rho!)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, find_pressure!)\n    apply!(sys, reset_a!)\n    apply!(sys, internal_force!)\n    apply!(sys, accelerate!)\nend\n\nfunction save_results!(out::SmoothedParticles.DataStorage, sys::ParticleSystem, k::Int64)\n    if (k %  Int64(round(dt_frame/dt)) == 0)\n        @printf(\"t = %.6e\\n\", k*dt)\n        #energy\n        E = sum(p -> energy(sys,p), sys.particles)\n        @show E\n        println(\"# of part. = \", length(sys.particles))\n        println()\n        save_frame!(out, sys, :v, :a, :P, :rho, :rho0)\n    end\nend\n\nfunction main(;revert = true) #if revert=true, velocities are inverted at the end of the simulation and the simulation then goes backward\n\tsys = make_system()\n\tout = new_pvd_file(\"results/collapse_fixpa\")\n    #initialization\n    create_cell_list!(sys)\n    apply!(sys, find_rho0!, self = true)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, find_pressure!)\n    apply!(sys, internal_force!)\n\n\tN_of_particles = length(sys.particles)\n\t@show(N_of_particles)\n\t@show(m)\n\n\n\tstep_final = Int64(round(t_end/dt))\n\ttimes = Float64[] #time instants\n\tSs = Float64[] # Entropy values\n\tEkin = Float64[] # Kinetic energy values\n\tfor k = 0 : step_final\n        verlet_step!(sys)\n        save_results!(out, sys, k)\n    \tif k % round(step_final/100) == 0 # store a number of entropy values\n\t\t\tdistr = velocity_histogram(sys, N = 100)\n\t\t\tS = entropy_2D_MB(distr)\n\t\t\tpush!(times, k*dt)\n\t\t\tpush!(Ss, S)\n\t\t\tpush!(Ekin, energy_kinetic(sys))\n\t\t\t@show(S)\n        \tprintln()\n\t\tend\n\tend","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Plotting the velocity distribution in comparison with Maxwell-Boltzmann","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"\tT = plot_velocity_distr(sys, m, \"energy_distribution_middle.pdf\")","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Plotting the entropy in time","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"\tSred_eq_E = [(1+log(Ekin[k]/(m*length(sys.particles)))) for k in 1:length(Ss)]\n\tSred_eq_T= (1+log(kB*T/m))*ones(Float64, length(Ss))\n\tp = plot(times, [Ss Sred_eq_T Sred_eq_E], label = [\"entropy\" \"S_eq(T)\" \"S_eq(E)\"],legend=:bottomright)\n\tsavefig(p, \"entropy_middle.pdf\")\n\tdf = DataFrame(time_steps = times, S_Boltzmann = Ss, S_eq_T = Sred_eq_T, S_eq_E = Sred_eq_E)\n\tCSV.write(\"entropy_middle.csv\", df)\n\n\tif revert\n\t\t#revert velocities\n\t\tprintln(\"--------------------\")\n\t\tprintln(\"Reverting velocities\")\n\t\tprintln(\"--------------------\")\n\t\tfor p in sys.particles\n\t\t\tp.v = -p.v\n\t\tend\n\t\tSs_rev = Float64[]\n\t\tfor k = step_final:-1:0\n\t\t\tverlet_step!(sys)\n\t\t\tsave_results!(out, sys, k)\n\t\t\tif k % round(step_final/100) == 0 # store a number of entropy values\n\t\t\t\tdistr = velocity_histogram(sys, v_max = sqrt(2*norm(g)*water_column_height), N = 100)\n\t\t\t\tS = entropy_2D_MB(distr)\n\t\t\t\tpush!(Ss_rev, S)\n\t\t\t\t@show(S)\n\t\t\t\tprintln()\n\t\t\tend\n\t\tend\n\t\tplot_velocity_distr(sys, m, \"energy_distribution_final.pdf\")","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"Plotting the entropy in time","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"\t\tp = plot(times, [Ss Ss_rev Sred_eq_T Sred_eq_E], label = [\"entropy forward\" \"entropy backward\" \"S_eq(T)\" \"S_eq(E)\"], legend=:bottomright)\n\t\tsavefig(p, \"entropy_final.pdf\")\n\t\tdf = DataFrame(time_steps = times, S_Boltzmann = Ss, S_eq_T = Sred_eq_T, S_eq_E = Sred_eq_E)\n\t\tCSV.write(\"entropy_final.csv\", df)\n\tend\n\n\tsave_pvd_file(out)\n\nend ## function main\n\nend ## module","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"","category":"page"},{"location":"examples/collapse_symplectic.html","page":"Water collapse (explicit, symplectic, and reversible)","title":"Water collapse (explicit, symplectic, and reversible)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"structs.html#Structs","page":"Structs","title":"Structs","text":"","category":"section"},{"location":"structs.html","page":"Structs","title":"Structs","text":"Modules = [SmoothedParticles]\nPages = [\"structs.jl\"]","category":"page"},{"location":"structs.html#SmoothedParticles.AbstractParticle","page":"Structs","title":"SmoothedParticles.AbstractParticle","text":"AbstractParticle\n\nAbstract supertype for smoothed particles. Any structure with AbstractParticle supertype is expected to:\n\nbe mutable\nhave field x::RealVector (particle position)\n\n\n\n\n\n","category":"type"},{"location":"structs.html#SmoothedParticles.ParticleField","page":"Structs","title":"SmoothedParticles.ParticleField","text":"ParticleField(sys::ParticleSystem, varS::Symbol)\n\nCreates an abstract array whose n-th element is the value of scalar varS of n-th particle in sys.\n\nwarning: Warning\nThe indentity of n-th particle in ParticleSystem may change when particles are added or removed.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#SmoothedParticles.ParticleSystem","page":"Structs","title":"SmoothedParticles.ParticleSystem","text":"ParticleSystem(T::Type, domain::Shape, h::Float64)\n\nStruct that contains all vital information about the simulation. The constructor specifies that:\n\nthe simulation will use particles of type T <: AbstractParticle,\nParticles outside of the 'domain' can be disregarded (and will be automatically removed).\nParticles are considered neighbours if their distance is less than h.\n\nPlease, do not make 'domain' unnecessarily large (has negative impact on performance).\n\n\n\n\n\n","category":"type"},{"location":"structs.html#SmoothedParticles.Shape","page":"Structs","title":"SmoothedParticles.Shape","text":"Shape\n\nSupertype for geometrical shapes.\n\n\n\n\n\n","category":"type"},{"location":"examples/cylinder.html#Flow-around-cylinder","page":"Flow around cylinder","title":"Flow around cylinder","text":"","category":"section"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"\t<img src='../assets/cylinder.png' width=\"50%\" height=\"50%\" alt='missing' /><br>","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"A simulation of flow around cylinder.\nAll parameters of this benchmark can be found\n <a href=\"http://www.mathematik.tu-dortmund.de/~featflow/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark1_re20.html\">here.</a>","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"The initial setup was created using the packing technique from a paper Particle packing algorithm for SPH schemes by Colagrosi et al.","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"module cylinder\n\nusing Printf\nusing SmoothedParticles\n\nconst folder_name = \"results/cylinder\"","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"Declare constants","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"#geometry parameters\nconst chan_l = 2.2\nconst chan_w = 0.41          #width of the channel\nconst cyl1 = 0.2             #x coordinate of the cylinder\nconst cyl2 = 0.005           #y coordinate of the cylinder\nconst cyl_r = 0.05           #radius of the cylinder\nconst dr = pi*cyl_r/20 \t\t #average particle distance (decrease to make finer simulation)\nconst h = 2.4*dr\nconst bc_width = 6*dr\nconst x2_min = -chan_w/2 - 6*dr\nconst x2_max =  chan_w/2 + 6*dr\n\n\n#physical parameters\nconst U_max = 0.3       #maximum inflow velocity\nconst rho0 = 1.0\t\t#referential fluid density\nconst m0 = rho0*dr^2\t#particle mass\nconst c = 20.0*U_max\t#numerical speed of sound\nconst mu = 1.0e-3\t\t#dynamic viscosity\nconst nu = 0.1*h*c      #pressure stabilization\n\n\n#temporal parameters\nconst dt = 0.1*h/c                     #time step\nconst t_end = 10.0                     #end of simulation\nconst dt_frame = max(dt, t_end/200)    #how often data is saved\nconst t_acc = 1.0                      #time to accelerate to full speed\nconst t_measure = t_end/2              #time from which we start measuring drag and lift\n\n#particle types\nconst FLUID = 0.\nconst INFLOW = 1.\nconst WALL = 2.\nconst OBSTACLE = 3.","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"Declare variables to be stored in a Particle","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"function check_symmetry(sys::ParticleSystem)::Bool\n    for p in sys.particles\n        has_mirror = false\n        _x = RealVector(p.x[1], -p.x[2], 0.0)\n        _v = RealVector(p.v[1], -p.v[2], 0.0)\n        _a = RealVector(p.a[1], -p.a[2], 0.0)\n        for q in sys.particles\n            if (q.x == _x) && (q.v == _v) && (q.a == _a)\n                has_mirror = true\n            end\n        end\n        if !has_mirror\n            return false\n        end\n    end\n    return true\nend\n\nmutable struct Particle <: AbstractParticle\n    x::RealVector #position\n    v::RealVector #velocity\n    a::RealVector #acceleration\n    rho::Float64 #density\n    Drho::Float64 #rate of density\n    P::Float64 #pressure\n    m::Float64 #mass\n    type::Float64 #particle type\n    Particle(x, type=FLUID) = begin\n        return new(x, VEC0, VEC0,  rho0, 0., 0., m0, type)\n    end\nend\n\nfunction make_system()\n    domain = Rectangle(-bc_width, x2_min, chan_l, x2_max)\n    sys = ParticleSystem(Particle, domain, h)\n    import_particles!(sys, \"init/cylinder.vtp\", x -> Particle(x))\n    @show check_symmetry(sys)\n    return sys\nend\n\n#Inflow function\n\nfunction set_inflow_speed!(p::Particle, t::Float64)\n    if p.type == INFLOW\n        s = min(1.0, t/t_acc)\n        v1 = s*U_max*(1.0 - (2.0*p.x[2]/chan_w)^2)\n        p.v = v1*VECX\n    end\nend\n\n#Define interactions between particles\n\n\n@inbounds function balance_of_mass!(p::Particle, q::Particle, r::Float64)\n\tker = q.m*rDwendland2(h,r)\n\tp.Drho += ker*(dot(p.x-q.x, p.v-q.v))\n    if p.type == FLUID && q.type == FLUID\n        p.Drho += 2*nu/p.rho*(p.rho - q.rho)\n    end\nend\n\nfunction find_pressure!(p::Particle)\n    if p.x[1] >= -bc_width + h\n\t     p.rho += p.Drho*dt\n    end\n\tp.Drho = 0.0\n\tp.P = c^2*(p.rho - rho0)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\tker = q.m*rDwendland2(h,r)\n    x_pq = p.x - q.x\n\tp.a += -ker*(p.P/p.rho^2 + q.P/q.rho^2)*x_pq\n    p.a += 8.0*ker*mu/(p.rho*q.rho)*dot(p.v - q.v, x_pq)/(r*r + 0.01*h*h)*x_pq\nend\n\nfunction move!(p::Particle)\n\tp.a = VEC0\n\tif p.type == FLUID || p.type == INFLOW\n\t\tp.x += dt*p.v\n\tend\nend\n\nfunction gravity(p::Particle)\n    #f = (RealVector(cyl1, cyl2, 0.0) - p.x)\n    f = RealVector(cyl1 - p.x[1], -p.x[2], 0.0)\n    absf2 = (cyl1 - p.x[1])^2 + p.x[2]^2\n    return 0.3*U_max^2*f/absf2\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += 0.5*dt*(p.a + gravity(p))\n\tend\nend\n\nfunction add_new_particles!(sys::ParticleSystem)\n    new_particles = Particle[]\n    for p in sys.particles\n        if p.type == INFLOW && p.x[1] >= 0\n            p.type = FLUID\n            x = p.x - bc_width*VECX\n            newp = Particle(x, INFLOW)\n            push!(new_particles, newp)\n        end\n    end\n    append!(sys.particles, new_particles)\nend\n\nfunction calculate_force(obstacle::Vector{Particle})::RealVector\n    F = sum(p -> p.m*p.a, obstacle)\n    L_char = 0.1\n    U_mean = 2/3*U_max\n    C = 2.0*F/(L_char*U_mean^2)\n    return C\nend\n\nfunction  main()\n    sys = make_system()\n\tout = new_pvd_file(folder_name)\n    save_frame!(out, sys, :v, :P, :rho, :type)\n    C_SPH = VEC0\n    C_ref = RealVector(5.57953523384, 0.010618948146, 0.)\n    nsteps = Int64(round(t_end/dt))\n    nsamples = 0\n    obstacle = filter(p -> p.type==OBSTACLE, sys.particles)\n    #a modified Verlet scheme\n\tfor k = 1 : nsteps\n        t = k*dt\n        apply!(sys, accelerate!)\n        apply!(sys, move!)\n        add_new_particles!(sys)\n        apply!(sys, p -> set_inflow_speed!(p,t))\n        create_cell_list!(sys)\n\t\tapply!(sys, balance_of_mass!)\n        apply!(sys, find_pressure!)\n        apply!(sys, internal_force!)\n        apply!(sys, accelerate!)\n\n        if t > t_measure\n            nsamples += 1\n            C_SPH += calculate_force(obstacle)\n        end\n\n        #save data at selected frames\n\n        if (k %  Int64(round(dt_frame/dt)) == 0)\n            @show t\n            @show check_symmetry(sys)\n            println(\"N = \", length(sys.particles))\n            println(\"C_drag = \", C_SPH[1]/nsamples)\n            println(\"ref value = \", C_ref[1])\n            println(\"C_lift = \", C_SPH[2]/nsamples)\n            println(\"ref value = \", C_ref[2])\n            save_frame!(out, sys, :v, :P, :rho, :type)\n        end\n\tend\n\tsave_pvd_file(out)\n    println()\n    C_SPH = C_SPH/nsamples\n    relative_error = norm(C_SPH - C_ref)/norm(C_ref)\n    @show C_SPH\n    @show C_ref\n    println(\"relative error = \",100*relative_error,\"%\")\nend\n\nend","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"","category":"page"},{"location":"examples/cylinder.html","page":"Flow around cylinder","title":"Flow around cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"algebra.html#Algebra","page":"Algebra","title":"Algebra","text":"","category":"section"},{"location":"algebra.html","page":"Algebra","title":"Algebra","text":"Modules = [SmoothedParticles]\nPages = [\"algebra.jl\"]","category":"page"},{"location":"algebra.html#SmoothedParticles.FMAT0","page":"Algebra","title":"SmoothedParticles.FMAT0","text":"FMAT0\n\nStatic 2x2 zero matrix.\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.FMAT1","page":"Algebra","title":"SmoothedParticles.FMAT1","text":"FMAT1\n\nStatic 2x2 identity matrix.\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.MAT0","page":"Algebra","title":"SmoothedParticles.MAT0","text":"MAT0\n\nStatic 3x3 zero matrix.\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.MAT1","page":"Algebra","title":"SmoothedParticles.MAT1","text":"MAT1\n\nStatic 3x3 identity matrix.\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.VEC0","page":"Algebra","title":"SmoothedParticles.VEC0","text":"VEC0\n\nStatic zero vector. Equivalent to zero(RealVector).\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.VECX","page":"Algebra","title":"SmoothedParticles.VECX","text":"VECX\n\nStatic cartesian basis vector in the X direction. Equivalent to RealVector(1.,0.,0.)\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.VECY","page":"Algebra","title":"SmoothedParticles.VECY","text":"VECY\n\nStatic cartesian basis vector in the Y direction. Equivalent to RealVector(0.,1.,0.).\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.VECZ","page":"Algebra","title":"SmoothedParticles.VECZ","text":"VECZ\n\nStatic cartesian basis vector in the Z direction. Equivalent to RealVector(0.,0.,1.).\n\n\n\n\n\n","category":"constant"},{"location":"algebra.html#SmoothedParticles.FlatMatrix","page":"Algebra","title":"SmoothedParticles.FlatMatrix","text":"FlatMatrix\n\nStatic matrix for faster 2d simulations\n\n\n\n\n\n","category":"type"},{"location":"algebra.html#SmoothedParticles.RealMatrix","page":"Algebra","title":"SmoothedParticles.RealMatrix","text":"RealMatrix\n\nStatic Float64 matrix with 3x3 elements.\n\n\n\n\n\n","category":"type"},{"location":"algebra.html#SmoothedParticles.RealVector","page":"Algebra","title":"SmoothedParticles.RealVector","text":"RealVector(x1::Float64, x2::Float64, x3::Float64)\n\nStatic Float64 vector with 3 elements.\n\n\n\n\n\n","category":"type"},{"location":"algebra.html#SmoothedParticles.cof-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.cof","text":"cof(A::FlatMatrix)::FlatMatrix\n\nCofactor of 2x2 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.cof-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.cof","text":"cof(A::RealMatrix)::RealMatrix\n\nCofactor matrix of 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.det-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.det","text":"det(A::FlatMatrix)::Float64\n\nDeterminant of 2x2 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.det-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.det","text":"det(A::RealMatrix)::Float64\n\nDeterminant of 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.dev-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.dev","text":"dev(A::FlatMatrix)::FlatMatrix\n\nDeviatoric part of matrix 2x2. That is, dev(A) = A - Tr(A)*I/2.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.dev-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.dev","text":"dev(A::RealMatrix)::RealMatrix\n\nDeviatoric part of 3x3 matrix. That is, dev(A) = A - Tr(A)*I/3.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.dot-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}, StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.dot","text":"dot(A::FlatMatrix, B::FlatMatrix)::Float64\n\nComputes the double dot product of two 2x2 matrices.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.dot-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.dot","text":"dot(A::RealMatrix, B::RealMatrix)::Float64\n\nComputes the double dot product of two 3x3 matrices.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.dot-Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}","page":"Algebra","title":"SmoothedParticles.dot","text":"dot(x::RealVector, y::RealVector)::Float64\n\nComputes the dot product of two vectors.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.inv-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.inv","text":"inv(A::FlatMatrix)::FlatMatrix\n\nInverse of 2x2 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.inv-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.inv","text":"inv(A::RealMatrix)::::RealMatrix\n\nInverse matrix of 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.norm-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.norm","text":"norm(x::FlatMatrix)::Float64\n\nComputes the norm of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.norm-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.norm","text":"norm(x::RealMatrix)::Float64\n\nComputes the norm of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.norm-Tuple{StaticArraysCore.SVector{3, Float64}}","page":"Algebra","title":"SmoothedParticles.norm","text":"norm(x::RealVector)::Float64\n\nComputes the norm of a vector.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.trace-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.trace","text":"trace(A::FlatMatrix)::Float64\n\nTrace of 2x2 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.trace-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.trace","text":"trace(A::RealMatrix)::Float64\n\nTrace of 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.trans-Tuple{StaticArraysCore.SMatrix{2, 2, Float64, 4}}","page":"Algebra","title":"SmoothedParticles.trans","text":"trans(A::FlatMatrix)::FlatMatrix\n\nTranspose of 2x2 matrix.\n\n\n\n\n\n","category":"method"},{"location":"algebra.html#SmoothedParticles.trans-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}}","page":"Algebra","title":"SmoothedParticles.trans","text":"trans(A::RealMatrix)::RealMatrix\n\nTranspose of 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"IO.html#Input/Output","page":"Input/Output","title":"Input/Output","text":"","category":"section"},{"location":"IO.html","page":"Input/Output","title":"Input/Output","text":"Modules = [SmoothedParticles]\nPages = [\"IO.jl\"]","category":"page"},{"location":"IO.html#SmoothedParticles.DataStorage","page":"Input/Output","title":"SmoothedParticles.DataStorage","text":"DataStorage\n\nStorage for paraview input/output.\n\n\n\n\n\n","category":"type"},{"location":"IO.html#SmoothedParticles.import_particles!-Tuple{ParticleSystem, String, Function}","page":"Input/Output","title":"SmoothedParticles.import_particles!","text":"import_particles!(sys::ParticleSystem, path::String, particle_constructor::Function)\n\nImports particles from a vtk file in 'path' using 'constructor' and add them to sys.\n\n\n\n\n\n","category":"method"},{"location":"IO.html#SmoothedParticles.new_pvd_file-Tuple{String}","page":"Input/Output","title":"SmoothedParticles.new_pvd_file","text":"new_pvd_file(path::String)::DataStorage\n\nCteates new DataStorage in a given path.\n\n\n\n\n\n","category":"method"},{"location":"IO.html#SmoothedParticles.save_frame!-Tuple{SmoothedParticles.DataStorage, ParticleSystem, Vararg{Symbol, N} where N}","page":"Input/Output","title":"SmoothedParticles.save_frame!","text":"save_frame!(data::DataStorage, sys::ParticleSystem, vars::DataField...)\n\nInserts one time frame into a DataStorage that includes all vars... as fields.\n\n\n\n\n\n","category":"method"},{"location":"IO.html#SmoothedParticles.save_pvd_file-Tuple{SmoothedParticles.DataStorage}","page":"Input/Output","title":"SmoothedParticles.save_pvd_file","text":"save_pvd_file(data::DataStorage)\n\nSaves and closes DataStorage.\n\n\n\n\n\n","category":"method"},{"location":"examples/static_container.html#Static-container","page":"Static container","title":"Static container","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"\t<img src='../assets/static_container.png' width=\"50%\" height=\"50%\" alt='missing' /><br>","category":"page"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"This is a hello world example of SPH. Simulates motionless fluid in uniform gravitational field. Ideally, nothing should happen because the initial state is stable. However, spurious oscillation are often encountered.","category":"page"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"Let us begin by declaring a module and importing some stuff.","category":"page"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"module static_container\n\nusing Printf\nusing SmoothedParticles","category":"page"},{"location":"examples/static_container.html#Declare-constant-parameters","page":"Static container","title":"Declare constant parameters","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"const dr = 1.5e-3       #average particle distance\nconst h = 1.8*dr        #size of kernel support\nconst rho0 = 1000.0     #fluid density\nconst m = rho0*dr^2     #particle mass\nconst c = 40.0          #numerical speed of sound\nconst g = -VECY         #gravitational acceleration\nconst mu = 8.4e-4       #dynamic viscosity of water\n\nconst water_depth = 0.14\nconst box_height = 0.18\nconst box_width = 0.14\nconst wall_width = 2.5*dr\n\n##temporal parameters\nconst dt = 0.2*h/c\nconst t_end = 0.5\nconst dt_frame = max(t_end/50, dt)\n\n##particle types\nconst FLUID = 0.\nconst WALL = 1.","category":"page"},{"location":"examples/static_container.html#Declare-variables-to-be-stored-in-a-Particle","page":"Static container","title":"Declare variables to be stored in a Particle","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"mutable struct Particle <: AbstractParticle\n\tx::RealVector #position\n\tv::RealVector #velocity\n\ta::RealVector #acceleration\n\trho::Float64 #density\n\ttype::Float64 #particle type\n\tParticle(x::RealVector, type::Float64) = new(\n\t\tx,\n\t\tVEC0,\n\t\tVEC0,\n\t\trho0,\n\t\ttype\n\t)\nend\n\n\n##dependance of pressure on density\nfunction pressure(p::Particle)\n\treturn c^2*(p.rho - rho0)\nend\n\n##fluid identier\nfunction isfluid(p::Particle)::Float64\n\treturn Float64(p.type == FLUID)\nend","category":"page"},{"location":"examples/static_container.html#Define-geometry-and-make-particles","page":"Static container","title":"Define geometry and make particles","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"function make_system()\n\tgrid = Grid(dr, :square)\n\tbox = Rectangle(0., 0., box_width, box_height)\n\tfluid = Rectangle(0., 0., box_width, water_depth)\n\twalls = BoundaryLayer(box, grid, wall_width)\n\tsys = ParticleSystem(Particle, box + walls, h)\n\tgenerate_particles!(sys, grid, fluid, x -> Particle(x, FLUID))\n\tgenerate_particles!(sys, grid, walls, x -> Particle(x,  WALL))\n\tfor p in sys.particles\n\t\tP = rho0*g[2]*(p.x[2] - water_depth)                       # hydrostatic pressure\n\t\tp.rho = rho0 + P/c^2                                               # solve for density\n\tend\n\tcreate_cell_list!(sys)\n\tapply!(sys, internal_force!)\n\treturn sys\nend","category":"page"},{"location":"examples/static_container.html#Define-particle-interactions","page":"Static container","title":"Define particle interactions","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"@inbounds function balance_of_mass!(p::Particle, q::Particle, r::Float64)\n\tp.rho += dt*dot(p.x-q.x, p.v-q.v)*m*rDwendland2(h,r)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\tif p.type == FLUID\n\t\tker = m*rDwendland2(h,r)\n\t\t#pressure force\n\t\tp.a += -ker*(pressure(p)/p.rho^2 + pressure(q)/q.rho^2)*(p.x - q.x)\n\t\t#viscous force\n\t\tp.a += ker*2*mu/(p.rho*q.rho)*(p.v - q.v)\n\tend\nend\n\nfunction move!(p::Particle)\n\tp.x += 0.5*dt*p.v\n\tp.a = VEC0\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += 0.5*dt*(p.a + g)\n\tend\nend","category":"page"},{"location":"examples/static_container.html#Put-everything-into-a-time-loop","page":"Static container","title":"Put everything into a time loop","text":"","category":"section"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"function main()\n\tsys = make_system()\n\t@show sys.key_max\n\tout = new_pvd_file(\"results/static_container\")\n\tfor k = 0 : Int64(round(t_end/dt))\n\t\tapply!(sys, accelerate!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, balance_of_mass!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, internal_force!)\n\t\tapply!(sys, accelerate!)\n\t\tif (k %  Int64(round(dt_frame/dt)) == 0)\n\t\t\t@printf(\"t = %.6e s \", k*dt)\n\t\t\tprintln(\"(\",round(100*k*dt/t_end),\"% complete)\")\n\t\t\tprintln(\"# of particles = \", length(sys.particles))\n\t\t\tprintln()\n\t\t\tsave_frame!(out, sys, :rho, :type, :v)\n\t\tend\n\tend\n\tsave_pvd_file(out)\nend ##function main()\n\nend ##module","category":"page"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"","category":"page"},{"location":"examples/static_container.html","page":"Static container","title":"Static container","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/drop.html#Surface-tension-simulation-in-3D","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"","category":"section"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"WARNING: Takes very long time to compute (hours on cluster for 0.1 second)","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"module drop\n\nusing Printf\nusing SmoothedParticles\nusing Parameters","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"Declare constant parameters","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"##geometrical\nconst dr = 3.7e-5          #average particle distance (decrease to make finer simulation)\nconst h = 3.0*dr           #size of kernel support\nconst rad = 1e-3\nconst deskw= 0.9h\n\n##physical\nconst rho0 = 1000.   \t   #fluid density\nconst m = rho0*dr^3        #particle mass\nconst mu = 0.1         #dynamic viscosity of water\nconst beta = 72e-3      #surface tension\nconst vol = dr^3\nconst g = -9.8*VECZ\nconst c = 10.0*max(sqrt(beta/rho0/dr), sqrt(4*norm(g)*rad))            #numerical speed of sound\n\n##temporal\nconst dt = 0.3*dr/c\nconst t_end = 2e-5\n#const t_end = 0.02\nconst dt_frame = max(t_end/50,dt)\n\n#artificial\nconst s0 = dr*dr/100\n\nconst FLUID = 0.\nconst SOLID = 1.\n\n@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector #position\n\tv::RealVector = VEC0 #velocity\n\ta::RealVector = VEC0 #acceleration\n\tP::Float64 = 0. #pressure\n\trho::Float64 = 0. #density\n    rho0::Float64 = 0.\n    n::RealVector = VEC0 #normal\n    type::Float64\nend","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"Define geometry and make particles","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"function make_system()\n\tgrid = Grid(dr, :cubic)\n    drop = Ball(0., 0., rad + h, rad)\n    desk = Box(-2rad, -2rad, -deskw, 2rad, 2rad, 0.)\n    dom = Box(-2rad, -2rad, -2deskw, 2rad, 2rad, 2.2rad)\n    sys = ParticleSystem(Particle, dom, h)\n\tgenerate_particles!(sys, grid, drop, x -> Particle(x=x, type=FLUID))\n    generate_particles!(sys, grid, desk, x -> Particle(x=x, type=SOLID))\n\treturn sys\nend","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"Define particle interactions","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"@inbounds function find_n!(p::Particle, q::Particle, r::Float64)\n    p.n += 2*vol*vol*rDwendland3(h,r)*(p.x - q.x)\nend\n\nfunction reset_n!(p::Particle)\n    p.n = VEC0\nend\n\nfunction normalize_n!(p::Particle)\n    s = norm(p.n)\n    p.n /= (s + s0)\nend\n\n@inbounds function find_rho!(p::Particle, q::Particle, r::Float64)\n    p.rho += m*wendland3(h,r)\nend\n\n@inbounds function find_rho0!(p::Particle, q::Particle, r::Float64)\n    p.rho0 += m*wendland3(h,r)\nend\n\nfunction find_pressure!(p::Particle)\n\tp.P = c^2*(p.rho - p.rho0)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\t\tker = m*rDwendland3(h,r)\n        #pressure\n\t\tp.a += -ker*(p.P/rho0^2 + q.P/rho0^2)*(p.x - q.x)\n\t\t#viscosity\n        p.a += 2*ker*mu/rho0^2*(p.v - q.v)\n        #surface tension\n        p.a -= 2*beta/rho0^2*(\n            (m*DDwendland3(h,r)-ker)*dot(p.x-q.x, p.n-q.n)*(p.x-q.x)/(r^2 + s0)\n            +ker*(p.n-q.n)\n        )\nend\n\nfunction reset_a!(p::Particle)\n    p.a = VEC0\nend\n\nfunction reset_rho!(p::Particle)\n    p.rho = 0.0\nend\n\nfunction move!(p::Particle)\n\tp.x += (p.type==FLUID)*dt*p.v\nend\n\nfunction accelerate!(p::Particle)\n\tp.v += (p.type==FLUID)*0.5*dt*(p.a+g)\nend\n\nfunction energy(p::Particle)::Float64\n\tkinetic = 0.5*m*dot(p.v, p.v)\n\tinternal =  0.5*m*c^2*(p.rho - p.rho0)^2/rho0^2\n    s = norm(p.n)\n    tensile = beta*(s - s0*log(s/s0+1))\n    potential = m*dot(p.x, -g)\n    return kinetic + internal + tensile + potential\nend","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"Put everything into a time loop","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"function verlet_step!(sys)\n    apply!(sys, accelerate!)\n    apply!(sys, move!)\n    create_cell_list!(sys)\n    apply!(sys, reset_rho!)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, reset_n!)\n    apply!(sys, find_n!, self = true)\n    apply!(sys, normalize_n!)\n    apply!(sys, find_pressure!)\n    apply!(sys, reset_a!)\n    apply!(sys, internal_force!)\n    apply!(sys, accelerate!)\nend\n\nfunction save_results!(out, sys, k)\n    @printf(\"t = %.6e\\n\", k*dt)\n    apply!(sys, reset_n!)\n    apply!(sys, find_n!, self = true)\n    save_frame!(out, sys, :v, :a, :P, :rho, :rho0, :type, :n)\nend\n\n\nfunction main()\n    E0 = 0.0\n\tsys = make_system()\n\tout = new_pvd_file(\"results/drop\")\n    #initialization\n    create_cell_list!(sys)\n    apply!(sys, find_rho0!, self = true)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, find_pressure!)\n    apply!(sys, find_n!)\n    apply!(sys, normalize_n!)\n    apply!(sys, internal_force!)\n\tfor k in 0 : Int64(round(t_end/dt))\n        verlet_step!(sys)\n        if (k %  Int64(round(dt_frame/dt)) == 0)\n            save_results!(out, sys, k)\n            E = sum(energy, sys.particles)\n            if k == 0\n                E0 = E\n            end\n            E = E - E0\n            @show E\n            println(\"# of part. = \", length(sys.particles))\n            println()\n        end\n\tend\n\tsave_pvd_file(out)\nend ## function main\n\n\nend ## module","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"","category":"page"},{"location":"examples/drop.html","page":"Surface tension simulation in 3D","title":"Surface tension simulation in 3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"grids.html#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids.html","page":"Grids","title":"Grids","text":"Modules = [SmoothedParticles]\nPages = [\"grids.jl\"]","category":"page"},{"location":"grids.html#SmoothedParticles.Grid-Tuple{Float64, Symbol}","page":"Grids","title":"SmoothedParticles.Grid","text":"Grid(dr::Float64, symm::Symbol)::Grid\n\nDefine a grid with a given characterstic length textdr and symmetry type symm. Characterstic length means that one particle occupies a volume textdr^n, where n is the dimension. Supported symmetry types are\n\n2D:\n\n:square (square grid)\n:hexagonal (hexagrid, dual of isometric grid)\n:vogel (grid based on Vogel's spiral, see: https://en.wikipedia.org/wiki/Fermat%27s_spiral)\n\n3D:\n\n:cubic (cubic grid, see: https://en.wikipedia.org/wiki/Cubiccrystalsystem)\n:facecentered (cubic face-centered grid)\n:bodycentered (cubic body-centered grid)\n:diamond (diamond cubic grid, see: https://en.wikipedia.org/wiki/Diamond_cubic)\n\n\n\n\n\n","category":"method"},{"location":"grids.html#SmoothedParticles.generate_particles!-Tuple{ParticleSystem, Grid, Shape, Function}","page":"Grids","title":"SmoothedParticles.generate_particles!","text":"generate_particles!(sys::ParticleSystem,\n                    grid::Grid,\n                    geometry::Shape,\n                    constructor::Function)\n\nCreate particles using constructor(x::RealVector)::AbstractParticle at every grid point inside a given shape.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#Kernels","page":"Kernels","title":"Kernels","text":"","category":"section"},{"location":"kernels.html","page":"Kernels","title":"Kernels","text":"Smoothing kernels are the guts of SPH. They measure the strength of interaction between neighbouring particles based on their distance. They are also used to interpolate particle variables into continuous Eulerian fields.","category":"page"},{"location":"kernels.html","page":"Kernels","title":"Kernels","text":"Modules = [SmoothedParticles]\nPages = [\"kernels.jl\"]","category":"page"},{"location":"kernels.html#SmoothedParticles.Dspline23-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.Dspline23","text":"Dspline23(h::Float64, r::Float64)::Float64\n\nReturns fractextdwtextdr(r), the first derivative of a 2d cubic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.Dspline24-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.Dspline24","text":"Dspline24(h::Float64, r::Float64)::Float64\n\nReturns fractextdwtextdr(r), the first derivative of a 2d quartic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.Dwendland2-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.Dwendland2","text":"Dwendland2(h::Float64, r::Float64)::Float64\n\nReturns fractextdwtextdr(r), the first derivative of a 2d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.Dwendland3-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.Dwendland3","text":"Dwendland3(h::Float64, r::Float64)::Float64\n\nReturns fractextdwtextdr(r), the first derivative of a 3d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.rDspline23-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.rDspline23","text":"rDspline23(h::Float64, r::Float64)::Float64\n\nReturns frac1rfractextdwtextdr(r), the reduced first derivative of a 2d cubic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.rDspline24-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.rDspline24","text":"rDspline24(h::Float64, r::Float64)::Float64\n\nReturns frac1rfractextdwtextdr(r), the reduced first derivative of a 2d quartic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.rDwendland2-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.rDwendland2","text":"rDwendland2(h::Float64, r::Float64)::Float64\n\nReturns frac1rfractextdwtextdr(r), the reduced first derivative of a 2d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.rDwendland3-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.rDwendland3","text":"rDwendland3(h::Float64, r::Float64)::Float64\n\nReturns frac1rfractextdwtextdr(r), the reduced first derivative of a 3d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.spline23-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.spline23","text":"spline23(h::Float64, r::Float64)::Float64\n\nReturns w(r), the value of a 2d cubic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.spline24-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.spline24","text":"spline24(h::Float64, r::Float64)::Float64\n\nReturns w(r), the value of a 2d quartic spline w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.wendland2-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.wendland2","text":"wendland2(h::Float64, r::Float64)::Float64\n\nReturns w(r), the value of a 2d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"kernels.html#SmoothedParticles.wendland3-Tuple{Float64, Float64}","page":"Kernels","title":"SmoothedParticles.wendland3","text":"wendland3(h::Float64, r::Float64)::Float64\n\nReturns w(r), the value of a 3d quintic Wendland kernel w with support radius h. Integrates to unity.\n\n\n\n\n\n","category":"method"},{"location":"core.html#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"core.html","page":"Core","title":"Core","text":"Modules = [SmoothedParticles]\nPages = [\"core.jl\"]","category":"page"},{"location":"core.html#SmoothedParticles.apply!-Tuple{ParticleSystem, Function}","page":"Core","title":"SmoothedParticles.apply!","text":"apply!(sys::ParticleSystem, action!::Function; self::Bool = false)\n\nCalls either apply_unary! or apply_binary! according to the signature of action!. If self == true, then particle self-interaction for binary operator is allowed.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.apply_binary!-Tuple{ParticleSystem, Function}","page":"Core","title":"SmoothedParticles.apply_binary!","text":"apply_binary!(sys::ParticleSystem, action!::Function)\n\nApply a binary operator action!(p::T, q::T, r::Float64) between any two neighbouring particles p, q in sys::ParticleSystem{T}. Value r is their mutual distance. This excludes particle pairs with distance greater than sys.h. This has linear complexity in number of particles and runs in parallel.\n\nwarning: Warning\nModifying second particle q within action! can lead to race condition, so do not do this. Also, make sure that result will not depend on the order of particle evaluation, which is implementation-specific.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.apply_unary!-Tuple{ParticleSystem, Function}","page":"Core","title":"SmoothedParticles.apply_unary!","text":"apply_unary!(sys::ParticleSystem, action!::Function)\n\nApply a unary operator action!(p::T) on every particle p in sys::ParticleSystem{T}.  This has linear complexity in number of particles and runs in parallel.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.assemble_matrix-Tuple{ParticleSystem, Function}","page":"Core","title":"SmoothedParticles.assemble_matrix","text":"assemble_matrix(sys::ParticleSystem, func::Function)::SparseMatrixCSC{Float64}\n\nFor given function func(p::T, q::T)::Float64 where T <: AbstractParticle, assemble a sparse matrix mathbbA, such that\n\n\tA_ij = textfunc(p_i p_j r_ij)\n\nwhere p_i, p_j are respectively the i-th and j-th particle in sys::ParticleSystem{T} and r_ij is their mutual distance. This assumes that A_ij = 0 for r_ij  h.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.assemble_vector-Tuple{ParticleSystem, Function}","page":"Core","title":"SmoothedParticles.assemble_vector","text":"assemble_vector(sys::ParticleSystem, func::Function)::Vector{Float64}\n\nFor given function func(q::T)::Float64 where T <: AbstractParticle, assemble a vector mathbfv, such that \n\n\tv_i =  textfunc(p_i)\n\nwhere p_i is the i-th particle in sys::ParticleSystem{T}.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.create_cell_list!-Tuple{ParticleSystem}","page":"Core","title":"SmoothedParticles.create_cell_list!","text":"create_cell_list!(sys::ParticleSystem)\n\nCreate the cell list for given particle system sys. This function should be always called after updating positions. Without updated cell list, applying binary particle operators or assembling matrices will lead to incorrect results.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.dist-Tuple{AbstractParticle, AbstractParticle}","page":"Core","title":"SmoothedParticles.dist","text":"dist(p::AbstractParticle, q::AbstractParticle)::Float64\n\nComputes the distance between any two particles.\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.sum-Tuple{ParticleSystem, Function, AbstractParticle}","page":"Core","title":"SmoothedParticles.sum","text":"sum(sys::ParticleSystem, func::Function, x::RealVector)::Float64\n\nFor given function func(p::T, q::T, r::Float64)::Float64 where T <: AbstractParticle and particle p it returns the sum\n\n\tsum_q in textsysparticles textfunc(p q r)\n\n\n\n\n\n","category":"method"},{"location":"core.html#SmoothedParticles.sum-Tuple{ParticleSystem, Function, StaticArraysCore.SVector{3, Float64}}","page":"Core","title":"SmoothedParticles.sum","text":"sum(sys::ParticleSystem, func::Function, x::RealVector)::Float64\n\nFor given function func(p::T, r::Float64)::Float64 where T <: AbstractParticle it returns the sum\n\n\tsum_p in textsysparticles textfunc(p sqrt(px - x)^2 + (py - y)^2)\n\nThis can be useful if one needs to compute SPH interpolation at a point which is not occupied by a particle.\n\n\n\n\n\n","category":"method"},{"location":"geometry.html#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry.html","page":"Geometry","title":"Geometry","text":"Modules = [SmoothedParticles]\nPages = [\"geometry.jl\"]","category":"page"},{"location":"geometry.html#SmoothedParticles.Ball","page":"Geometry","title":"SmoothedParticles.Ball","text":"Ball(x1::Float64, x2::Float64, x3::Float64, r::Float64) <: Shape\n\nDefine a ball by specifying the center (x1, x2, x3) and the radius r.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.BooleanDifference","page":"Geometry","title":"SmoothedParticles.BooleanDifference","text":"BooleanDifference(s1::Shape, s2::Shape) <: Shape\n\nDefine a shape as difference of two shapes. Equivalent to s1 - s2.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.BooleanIntersection","page":"Geometry","title":"SmoothedParticles.BooleanIntersection","text":"BooleanIntersection(s1::Shape, s2::Shape) <: Shape\n\nDefine a shape as intersection of two shapes. Equivalent to s1 * s2.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.BoundaryLayer","page":"Geometry","title":"SmoothedParticles.BoundaryLayer","text":"BoundaryLayer(s::Shape, grid::Grid, width::Float64) <: Shape\n\nCreates a layer of certain width around shape s. More specifically, a point is inside boundary layer if it is not in s and at the same time has distance less than width to at least one point on grid in s.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Box","page":"Geometry","title":"SmoothedParticles.Box","text":"Box(x1_min::Float64, x2_min::Float64, x3_min::Float64,\n    x1_max::Float64, x2_max::Float64, x3_max::Float64)::Shape\n\nDefines a box specified by two corners.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Circle","page":"Geometry","title":"SmoothedParticles.Circle","text":"Circle(x1::Float64, x2::Float64, r::Float64) <: Shape\n\nDefine a circle by specifying the center (x1, x2) and the radius r.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Ellipse","page":"Geometry","title":"SmoothedParticles.Ellipse","text":"Ellipse(x1::Float64, x2::Float64, r1::Float64, r2::Float64) <: Shape\n\nDefine an ellipse by specifying the center (x1, x2) and semi-major/minor axes r1, r2.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Ellipsoid","page":"Geometry","title":"SmoothedParticles.Ellipsoid","text":"Ellipsoid(x1::Float64, x2::Float64, x3::Float64, r1::Float64, r2::Float64, r3::Float64) <: Shape\n\nDefine an ellipsoid by specifying the center (x1, x2, x3) and three radii r1,r2,r3.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Polygon","page":"Geometry","title":"SmoothedParticles.Polygon","text":"Polygon(x::Tuple{Float64, Float64}...)\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Specification","page":"Geometry","title":"SmoothedParticles.Specification","text":"Specification(s::Shape, f::Function) <: Shape\n\nDefine a shape of all x in s, such that f(x) == true.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.Transform","page":"Geometry","title":"SmoothedParticles.Transform","text":"Transform(s::Shape; A::RealMatrix = MAT1, b::RealVector = VEC0)\n\nDefine shape as a linear transform x to Ax + b applied to shape s.\n\n\n\n\n\n","category":"type"},{"location":"geometry.html#SmoothedParticles.ClosedSpline-Tuple{Vararg{Tuple{Float64, Float64}, N} where N}","page":"Geometry","title":"SmoothedParticles.ClosedSpline","text":"ClosedSpline(x::Tuple{Float64, Float64}...; n::Int64 = 32)\n\n\n\n\n\n","category":"method"},{"location":"geometry.html#SmoothedParticles.Rectangle-NTuple{4, Float64}","page":"Geometry","title":"SmoothedParticles.Rectangle","text":"Rectangle(x1_min, x2_min, x1_max, x2_max) <: Shape\n\nDefine a rectangle by specifying bottom left and top right corner.\n\n\n\n\n\n","category":"method"},{"location":"examples/Kepler_vortex.html#Kepler-vortex-(explicit,-symplectic,-and-reversible)","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"","category":"section"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"\t<img src='../assets/Kepler.png' alt='missing' width=\"50%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Kepler vortex, where a fluid forms a Gaussian ring rotating around the center of gravity. The ring is centered around r0=10 with standard deviation 25 (approximately nine thousand particles). Strength of the gravity is GM=1000, and speed of sound is chosen as c=0001 v_varphi, where v_varphi is the velocity at r_0. The final time is approximately 63, which corresponds to ten revolutions of the ring.","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"module Kepler_vortex\n\nusing Printf\nusing SmoothedParticles\nusing Parameters\nusing Plots\nusing DataFrames # to store the csv file\nusing CSV # to store the csv file\nusing QuadGK #To calculate the integral over Σ\nusing Interpolations\nusing Roots\ninclude(\"utils/FixPA.jl\")\nusing .FixPA","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Declare constant parameters","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"##graviational\nconst r0 = 10.0 #central ring radius\nconst GM = 1000. #graviational foce","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Calculate the Gaussian distribution of particles in the vortex, according to Cartwright et al.","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"function vphi_r(r::Float64)::Float64\n\treturn sqrt(GM)/sqrt(r)\nend\nconst vphi0 = vphi_r(r0)\n@show vphi0\nconst omega0= vphi0/r0\n@show omega0\n\nfunction Σ(r::Float64)::Float64\n\treturn 2*pi*r*exp(-30*(1-r/r0)^2)\nend\nconst denominator = quadgk(Σ, 0, 40, rtol=1.0e-06)[1]\n@show denominator\nfunction f(r::Float64)::Float64\n\treturn quadgk(Σ, 0, r, rtol=1.0e-03)[1]/denominator\nend\n\nconst rs = 0.:0.5:25.0 # collection of radii\nconst f_table = [f(r) for r in rs]\nconst f_interpolation = interpolate(f_table, BSpline(Cubic(Line(OnGrid()))))\nconst f_interpolation_scaled = scale(f_interpolation, rs)\nfunction r_f(F::Float64)::Float64 #radius as a function of the uniformly distributed random variable\n\treturn find_zero(x -> (f_interpolation_scaled(x)-F), r0)\nend\n@show r_f(0.5)\n\n# computational\n#const rs_in_vortex = 7.:dr:14. # equidistant rings in the vortex. Boundaries chosen as the edges of the histogram for 10^4 points over the interval [0,1]\nconst N_rings = 25\n@show N_rings\nconst rs_in_vortex = [r_f(u) for u in 0.01:(0.99-0.01)/N_rings:0.99] # Gaussian rings\ndr = r_f(0.25+1/N_rings)-r_f(0.25)\n@show dr\n\nconst h = 3.0*dr           #size of kernel support\nconst rho0 = 1.   \t   #fluid density\nconst m = rho0*dr^2        #particle mass\n#const mu = 0.0#8.4e-4          #dynamic viscosity of water\n\n##geometrical\nconst box_width = 4*r0\nconst wall_width = 2.5*dr\n\n##artificial\nconst c = 0.01             #numerical speed of sound\nconst dr_wall = 0.95*dr\nconst E_wall = GM/r0\nconst eps = 1e-16\n\n##temporal\nconst dt = 0.0001*h/c\n@show dt\nconst t_end = 10 * 2 * pi / omega0 #ten revolutions\n@show t_end\nconst dt_frame = t_end/200\n\n##particle types\nconst FLUID = 0.\nconst WALL = 1.\n\n@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector #position\n\tv::RealVector = VEC0 #velocity\n\ta::RealVector = VEC0 #acceleration\n\tP::Float64 = 0. #pressure\n\trho::Float64 = 0. #density\n    rho0::Float64 = 0.\n\ttype::Float64 #particle_type\nend","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Define geometry and make particles","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"function generate_circle!(sys::ParticleSystem, r::Float64, dφ::Float64; φ_start=0.0, x_center=0.0, y_center=0.0, vφ= 0.0)\n\tφ = φ_start\n\twhile φ < 2*pi+φ_start\n\t\tx = cos(φ) #x position on unit circle\n\t\ty = sin(φ) #y position on unit circle\n\t\tparticle_position = RealVector(x_center+r*x, y_center+r*y, 0.)\n\t\tparticle_velocity = RealVector(-vφ*y, vφ*x, 0.)\n\t\tpush!(sys.particles, Particle(x=particle_position, v=particle_velocity, type = FLUID))\n\t\tφ += dφ\n\tend\nend\n\nfunction make_system()\n    domain = Rectangle(-box_width, -box_width, box_width, box_width)\n    sys = ParticleSystem(Particle, domain, h)\n\n\tdφ = rs_in_vortex[2]/rs_in_vortex[1]-1.0 # increment in the angle\n\tfor i in 1:length(rs_in_vortex)-1 # not the last one because dphi would be unknown\n\t\tr = rs_in_vortex[i]\n\t\tgenerate_circle!(sys, r, dφ; vφ = vphi_r(r))\n\t\tdφ = (rs_in_vortex[i+1]-r)/r\n\tend\n\n\treturn sys\nend","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Define particle interactions","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"@inbounds function find_rho!(p::Particle, q::Particle, r::Float64)\n    if p.type == FLUID && q.type == FLUID\n\t\tp.rho += m*wendland2(h,r)\n\tend\nend\n\n@inbounds function find_rho0!(p::Particle, q::Particle, r::Float64)\n    if p.type == FLUID && q.type == FLUID\n\t\tp.rho0 += m*wendland2(h,r)\n\tend\nend\n\nfunction find_pressure!(p::Particle)\n\tp.P = c^2*(p.rho - p.rho0)\nend\n\n@inbounds function internal_force!(p::Particle, q::Particle, r::Float64)\n\tif p.type == FLUID && q.type == FLUID\n\t\tker = m*rDwendland2(h,r)\n\t\tp.a += -ker*(p.P/rho0^2 + q.P/rho0^2)*(p.x - q.x)\n\t\t#p.a += +2*ker*mu/rho0^2*(p.v - q.v)\n\telseif p.type == FLUID && q.type == WALL && r < dr_wall\n\t\ts = dr_wall/(r + eps)\n\t\tp.a += -E_wall/(r + eps)^2*(s^2 - s^4)*(p.x - q.x)\n\tend\nend\n\nfunction reset_a!(p::Particle)\n    p.a = zero(RealVector)\nend\n\nfunction reset_rho!(p::Particle)\n    p.rho = 0.0\nend\n\nfunction move!(p::Particle)\n\tif p.type == FLUID\n\t\tp.x = rev_add(p.x, dt*p.v)\n\tend\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v = rev_add(p.v, 0.5*dt*(rev_add(p.a, -GM/(norm(p.x)^3)*p.x)))\n\tend\nend\n\nfunction LJ_potential(p::Particle, q::Particle, r::Float64)::Float64\n\tif q.type == WALL && p.type == FLUID && r < dr_wall\n\t\ts = dr_wall/(r + eps)\n\t\treturn m*E_wall*(0.5s^2 - 0.25s^4 -0.25)\n\telse\n\t\treturn 0.0\n\tend\nend\n\nfunction energy_kinetic(sys::ParticleSystem)::Float64\n\treturn sum(p -> 0.5*m*dot(p.v, p.v), sys.particles)\nend\n\nfunction energy_potential(sys::ParticleSystem)::Float64\n\treturn sum(p -> -GM*m/(norm(p.x)), sys.particles)\nend\n\nfunction energy_internal(sys::ParticleSystem)::Float64\n\treturn sum(p -> 0.5*m*c^2*(p.rho - p.rho0)^2/rho0^2, sys.particles)\nend\n\n\nfunction energy(sys::ParticleSystem, p::Particle)::Float64\n\tkinetic = 0.5*m*dot(p.v, p.v)\n\tinternal =  0.5*m*c^2*(p.rho - p.rho0)^2/rho0^2\n\tgravity_potential = - GM*m/(norm(p.x))\n\twall_potential = SmoothedParticles.sum(sys, LJ_potential, p)\n\treturn kinetic + internal + gravity_potential + wall_potential\nend","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"Put everything into a time loop","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"function verlet_step!(sys::ParticleSystem)\n    apply!(sys, accelerate!)\n    apply!(sys, move!)\n    create_cell_list!(sys)\n    apply!(sys, reset_rho!)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, find_pressure!)\n    apply!(sys, reset_a!)\n    apply!(sys, internal_force!)\n    apply!(sys, accelerate!)\nend\n\nfunction save_results!(out::SmoothedParticles.DataStorage, sys::ParticleSystem, k::Int64)\n    if (k %  Int64(round(dt_frame/dt)) == 0)\n        @printf(\"t = %.6e\\n\", k*dt)\n        #energy\n        Etot = sum(p -> energy(sys,p), sys.particles)\n        @show Etot\n        Ekin = energy_kinetic(sys)\n        @show Ekin\n        Epot = energy_potential(sys)\n        @show Epot\n        Eint = energy_internal(sys)\n        @show Eint\n        println(\"# of part. = \", length(sys.particles))\n        println()\n        save_frame!(out, sys, :v, :a, :P, :rho, :rho0)\n    end\nend\n\nfunction main()\n\tsys = make_system()\n\tout = new_pvd_file(\"results/Kepler_vortex\")\n\n    #initialization\n    create_cell_list!(sys)\n    apply!(sys, find_rho0!, self = true)\n    apply!(sys, find_rho!, self = true)\n    apply!(sys, find_pressure!)\n    apply!(sys, internal_force!)\n\n\tN_of_particles = length(sys.particles)\n\t@show(N_of_particles)\n\t@show(m)\n\n\tstep_final = Int64(round(t_end/dt))\n\tfor k = 0 : step_final\n        verlet_step!(sys)\n        save_results!(out, sys, k)\n\tend\n\n\tsave_pvd_file(out)\n\nend ## function main\n\nend ## module","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"","category":"page"},{"location":"examples/Kepler_vortex.html","page":"Kepler vortex (explicit, symplectic, and reversible)","title":"Kepler vortex (explicit, symplectic, and reversible)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/collapse_dry.html#Water-collapse-(explicit)","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"\t<img src='../assets/collapse.png' alt='missing' width=\"50%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Simulation of a water column collapsing under its own weight. This would be very difficult to make in a mesh-based method like FDM, FEM or FVM. Fortunately, SPH turns this into an easy task. We use a very basic explicit SPH scheme with pressure-stabilized Verlet time integrator. This benchmark is (more or less) a recomputation of a simulation described in D. Violeau, FLUID MECHANICS AND THE SPH METHOD, page 484. We show how to implement it using SmoothedParticles.jl. Dependencies can be installed with","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"import Pkg\nPkg.add(\"Printf\")\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nPkg.add(\"Parameters\")\nPkg.add(\"Plots\")","category":"page"},{"location":"examples/collapse_dry.html#Import-essential-packages.","page":"Water collapse (explicit)","title":"Import essential packages.","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"module collapse_dry\n\nusing Printf\nusing SmoothedParticles\nusing CSV\nusing DataFrames\nusing Parameters\nusing Plots","category":"page"},{"location":"examples/collapse_dry.html#Constant-parameters","page":"Water collapse (explicit)","title":"Constant parameters","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Importantly, modifier const avoids memory allocations.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"# physical\nconst dr = 1.5e-2          # average particle distance (decrease to refine, increase to speed up)\nconst h = 3.0*dr           # size of kernel radius (twice the smoothing length)\nconst rho0 = 1000.   \t   # fluid density\nconst m = rho0*dr^2        # particle mass\nconst c = 50.0             # numerical speed of sound\nconst g = -7.0*VECY        # gravitational acceleration\nconst mu = 8.4e-4          # dynamic viscosity of water\nconst nu = 1.0e-6          # artificial pressure stabilization\n\n# geometrical\nconst water_column_width = 1.0\nconst water_column_height = 2.0\nconst box_height = 3.0\nconst box_width = 4.0\nconst wall_width = 2.5*dr\n\n# temporal\nconst dt = 0.1*h/c                      # numerical time step\nconst t_end = 4.0                       # when to terminate (in seconds)\nconst dt_frame = max(dt,t_end/200)      # time step in the output (dt = dt_frame would save every frame, generating huge files)\n\n\n##particle types\nconst FLUID = 0.   # fluid marker\nconst WALL = 1.    # wall marker","category":"page"},{"location":"examples/collapse_dry.html#Particle-variables","page":"Water collapse (explicit)","title":"Particle variables","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector         # position\n\tv::RealVector = VEC0  # velocity\n\tDv::RealVector = VEC0 # acceleration\n\trho::Float64 = rho0   # density\n\tDrho::Float64 = 0.    # rate of density\n\tP::Float64 = 0.       # pressure\n\ttype::Float64         # particle_type\nend","category":"page"},{"location":"examples/collapse_dry.html#Geometry","page":"Water collapse (explicit)","title":"Geometry","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function make_system()\n\tgrid = Grid(dr, :hexagonal)                                              # use hexagonal grid\n\tbox = Rectangle(0., 0., box_width, box_height)                           # laboratory box\n\tfluid = Rectangle(0., 0., water_column_width, water_column_height)       # column of fluid\n\twalls = BoundaryLayer(box, grid, wall_width)                             # walls around laboratory box\n\twalls = Specification(walls, x -> (x[2] < box_height))                   # remove top lid\n\tsys = ParticleSystem(Particle, box + walls, h)                           # define particle system by specifying particle type, domain and maximal kernel radius\n\tgenerate_particles!(sys, grid, fluid, x -> Particle(x=x, type=FLUID))    # fill fluid geometry with particles\n\tgenerate_particles!(sys, grid, walls, x -> Particle(x=x, type=WALL))     # fill wall geometry with particles\n\tfor p in sys.particles\n\t\tp.P = rho0*g[2]*(p.x[2] - water_column_height)                       # hydrostatic pressure\n\t\tp.rho = rho0 + p.P/c^2                                               # solve for density\n\tend\n\treturn sys\nend","category":"page"},{"location":"examples/collapse_dry.html#Particle-interactions","page":"Water collapse (explicit)","title":"Particle interactions","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Rate of density is","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"dotvarrho_p = sum_q m_q left( mathbfx_pq cdot mathbfv_pq + 2 nu varrho_pq right) fracw_pqr_pq","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function balance_of_mass!(p::Particle, q::Particle, r::Float64)\n\tker = m*rDwendland2(h,r)\n\tp.Drho += ker*(dot(p.x-q.x, p.v-q.v) + 2*nu*(p.rho-q.rho))\nend","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Linear formula for pressure. Tait equation can be used instead but the difference is mostly negligible.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"P_p = c^2 (varrho_p - varrho_0)","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function find_pressure!(p::Particle)\n\tp.rho += p.Drho*dt\n\tp.Drho = 0.0\n\tp.P = c^2*(p.rho - rho0)\nend","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Internal forces between particles are pressure and viscosity. Wall particles are excluded.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"dotmathbfv_p = -sum_q m_q left( fracP_prho_p^2 + fracP_qrho_q^2 right)  fracw_pqr_pq mathbfx_pq + frac2 murho_0^2sum_q m_q  fracw_pqr_pq mathbfv_pq","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function internal_force!(p::Particle, q::Particle, r::Float64)\n\tif p.type == FLUID\n\t\tker = m*rDwendland2(h,r)\n\t\tp.Dv += -ker*(p.P/p.rho^2 + q.P/q.rho^2)*(p.x - q.x)\n\t\tp.Dv += +2*ker*mu/rho0^2*(p.v - q.v)\n\tend\nend","category":"page"},{"location":"examples/collapse_dry.html#Position-and-velocity-updates","page":"Water collapse (explicit)","title":"Position and velocity updates","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Updating by half-time step is a feature of Verlet integrator.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function move!(p::Particle)\n\tp.Dv = VEC0\n\tif p.type == FLUID\n\t\tp.x += 0.5*dt*p.v\n\tend\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += 0.5*dt*(p.Dv + g)\n\tend\nend","category":"page"},{"location":"examples/collapse_dry.html#Extract-global-variables","page":"Water collapse (explicit)","title":"Extract global variables","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Variables of interest are total energy, water column height and wavefront location.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function energy(p::Particle)::Float64\n\tkinetic = 0.5*m*dot(p.v, p.v)\n\tpotential = -m*dot(g, p.x)\n\tinternal =  m*c^2*(log(abs(p.rho/rho0)) + rho0/p.rho - 1.0)\n\treturn kinetic + potential + internal\nend\n\nfunction get_globals(sys::ParticleSystem)::NTuple{3,Float64}\n\tH = 0.0  # height of water column\n\tX = 0.0  # wavefront x-coordinate\n\tE = 0.0  # total energy\n\tfor p in sys.particles\n\t\tif p.type == FLUID\n\t\t\tX = max(X, p.x[1]/water_column_width)\n\t\tend\n\t\tif p.type == FLUID && 2.0 > p.x[1] > h\n\t\t\tH = max(H, p.x[2]/water_column_height)\n\t\tend\n\t\tE += energy(p)\n\tend\n\treturn (X,H,E)\nend","category":"page"},{"location":"examples/collapse_dry.html#Time-loop","page":"Water collapse (explicit)","title":"Time loop","text":"","category":"section"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"SmoothedParticles.jl will automatically run this in parallel and use neighbor list acceleration. Command create_cell_list!(sys) must be called at the beginning and each time after particles move.","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function main()\n\tts = []\n\tXs = []\n\tHs = []\n\tsys = make_system()\n\tout = new_pvd_file(\"results/collapse_dry\")\n\tcreate_cell_list!(sys)\n\tapply!(sys, internal_force!)\n\t@time for k = 0 : round(Int64, t_end/dt)\n\t\tapply!(sys, accelerate!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, balance_of_mass!)\n\t\tapply!(sys, find_pressure!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, internal_force!)\n\t\tapply!(sys, accelerate!)\n\t\t# save data at selected frames\n\t\tif (k % round(Int64, dt_frame/dt) == 0)\n\t\t\t@printf(\"t = %.6e s \", k*dt)\n\t\t\tprintln(\"(\",round(100*k*dt/t_end),\"% complete)\")\n\t\t\t(X, H, E) = get_globals(sys)\n\t\t\t@printf(\"energy = %.6e J\\n\", E)\n\t\t\t@printf(\"\\n\")\n\t\t\tpush!(Xs, X)\n\t\t\tpush!(Hs, H)\n\t\t\tpush!(ts, k*dt*sqrt(-2*g[2]))\n\t\t\tsave_frame!(out, sys, :v, :P, :type)\n\t\tend\n\tend\n\tsave_pvd_file(out)\n\tdata = DataFrame(time = ts, X = Xs, H = Hs)\n\tCSV.write(\"results/collapse_dry/data.csv\", data)\n\t@info \"drawing a plot with results\"\n\tmake_plot()\nend ## function main","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"Compare computed results to the book by Violeau and the experiment of Koshizuka and Oka (1996)","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"function make_plot()\n\tdata = CSV.read(\"results/collapse_dry/data.csv\", DataFrame)\n\tX_VIO = CSV.read(\"reference/dambreak_X_Violeau.csv\", DataFrame)\n\tX_KOS = CSV.read(\"reference/dambreak_X_Koshizuka.csv\", DataFrame)\n\tH_VIO = CSV.read(\"reference/dambreak_H_Violeau.csv\", DataFrame)\n\tH_KOS = CSV.read(\"reference/dambreak_H_Koshizuka.csv\", DataFrame)\n\tp1 = plot(data.time, data.X, label = \"SmoothedParticles.jl\", xlims = (0., 3.0))\n\tscatter!(p1, X_VIO.time, X_VIO.X, label = \"Violeau\")\n\tscatter!(p1, X_KOS.time, X_KOS.X, label = \"Koshizuka&Oda\", markershape = :square)\n\tsavefig(p1, \"results/collapse_dry/dambreak_X.pdf\")\n\tp2 = plot(data.time, data.H, label = \"SmoothedParticles.jl\", xlims = (0., 3.0))\n\tscatter!(p2, H_VIO.time, H_VIO.H, label = \"Violeau\")\n\tscatter!(p2, H_KOS.time, H_KOS.H, label = \"Koshizuka&Oda\", markershape = :square)\n\tsavefig(p2, \"results/collapse_dry/dambreak_H.pdf\")\nend\n\nend ## module","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"","category":"page"},{"location":"examples/collapse_dry.html","page":"Water collapse (explicit)","title":"Water collapse (explicit)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/cavity_flow.html#Lid-driven-cavity","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Standard CFD benchmark, which allows comparison with very accurate mesh-based methods. Description of the problem can be found on many webpages, like here. In the image below, you can see streamlines for Re = 400 and N = 320. This was computed on cluster and took some time. To correctly resolve corner vortices is much more demanding in SPH than in FEM.","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"\t<img src='../assets/cavity.png' alt='missing' width=\"50%\" height=\"50%\" /><br>","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Result is compared to the referential solution by Ghia et al 1980.","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"module cavity_flow\n\nusing Printf\nusing SmoothedParticles\nusing Plots, CSV, DataFrames, Printf, LaTeXStrings, Parameters","category":"page"},{"location":"examples/cavity_flow.html#Declare-const-parameters-(dimensionless-problem)","page":"Lid-driven cavity","title":"Declare const parameters (dimensionless problem)","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"##geometrical/physical parameters\nconst N  =   100                #number of sample points\nconst Re =   100                #Reynolds number\nconst llid = 1.0                #length of the lid\nconst mu =   1.0/Re             #viscosity\nconst rho0 = 1.0                #density\nconst vlid = 1.0                #flow speed of the lid\nconst dr = llid/N \t\t        #interparticle distance\nconst h = 3.0*dr\t\t        #size of kernel support\nconst m = rho0*dr^2             #particle mass\nconst c = 20*vlid\t\t    \t#numerical speed of sound\nconst P0 = 5.0                  #background pressure (good to prevent tensile instability)\nconst wwall = h\n\n##temporal parameters\nconst dt = 0.1*h/c                       #numerical time-step\nconst t_end = 0.4                        #end of simulation\nconst dt_frame = max(dt, t_end/200)      #how often save data\n\n##particle types\nconst FLUID = 0.\nconst WALL = 1.\nconst LID = 2.\n\n##path to store results\nconst path = \"results/cavity_flow\"*string(Re)","category":"page"},{"location":"examples/cavity_flow.html#Declare-variables-to-be-stored-in-a-Particle","page":"Lid-driven cavity","title":"Declare variables to be stored in a Particle","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"@with_kw mutable struct Particle <: AbstractParticle\n\tx::RealVector=VEC0\t#position\n\tv::RealVector=VEC0  #velocity\n\tDv::RealVector=VEC0 #acceleratation\n\trho::Float64=rho0   #density\n\tDrho::Float64=0.0   #rate of density\n\tP::Float64=0.0      #pressure\n\ttype::Float64       #particle type\nend","category":"page"},{"location":"examples/cavity_flow.html#Define-geometry-and-create-particles","page":"Lid-driven cavity","title":"Define geometry and create particles","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"function make_system()\n\tgrid = Grid(dr, :hexagonal)\n\tbox = Rectangle(0., 0., llid, llid)\n\twall = BoundaryLayer(box, grid, wwall)\n\tsys = ParticleSystem(Particle, box + wall, h)\n\tlid   = Specification(wall, x -> x[2] > llid)\n\twall = Specification(wall, x -> x[2] <= llid)\n\tgenerate_particles!(sys, grid, box, x -> Particle(x=x, type=FLUID))\n\tgenerate_particles!(sys, grid, lid, x -> Particle(x=x, type=LID))\n\tgenerate_particles!(sys, grid, wall, x -> Particle(x=x, type=WALL))\n\tcreate_cell_list!(sys)\n\tapply!(sys, find_pressure!)\n\tapply!(sys, internal_force!)\n\treturn sys\nend","category":"page"},{"location":"examples/cavity_flow.html#Define-interactions-between-particles","page":"Lid-driven cavity","title":"Define interactions between particles","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"function balance_of_mass!(p::Particle, q::Particle, r::Float64)\n\tp.Drho += m*rDwendland2(h,r)*(dot(p.x-q.x, p.v-q.v))\nend\n\nfunction find_pressure!(p::Particle)\n\tp.rho += p.Drho*dt\n\tp.Drho = 0.0\n\tp.P = P0 + c^2*(p.rho-rho0)\nend\n\nfunction internal_force!(p::Particle, q::Particle, r::Float64)\n\trDk = rDwendland2(h,r)\n\tx_pq = p.x - q.x\n\tv_pq = p.v - q.v","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"implementation of the Dirichlet boundary condition at the lid v_q is estimated using linear extrapolation","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"\tif q.type == LID\n        s = abs(x_pq[2])/(0.1*h + abs(p.x[2] - 1.0))\n        v_pq = s*(p.v - vlid*VECX)\n    end\n\tp.Dv += -m*rDk*(p.P/p.rho^2 + q.P/q.rho^2)*x_pq\n\tp.Dv += 8/(Re*p.rho*q.rho)*m*rDk*dot(v_pq, x_pq)/(r^2 + 0.01*h^2)*x_pq #Monaghan's type of viscosity to conserve angular momentum\nend\n\n\nfunction move!(p::Particle)\n\tp.Dv = VEC0\n\tif p.type == FLUID\n\t\tp.x += 0.5*dt*p.v\n\tend\nend\n\nfunction accelerate!(p::Particle)\n\tif p.type == FLUID\n\t\tp.v += 0.5*dt*p.Dv\n\tend\nend","category":"page"},{"location":"examples/cavity_flow.html#Time-iteration","page":"Lid-driven cavity","title":"Time iteration","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"function main()\n\tsys = make_system()\n\tout = new_pvd_file(path)\n\t@time for k = 0 : Int64(round(t_end/dt))\n\t\tapply!(sys, accelerate!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, balance_of_mass!)\n\t\tapply!(sys, find_pressure!)\n\t\tapply!(sys, move!)\n\t\tcreate_cell_list!(sys)\n\t\tapply!(sys, internal_force!)\n\t\tif (k % Int64(round(dt_frame/dt)) == 0) #save the frame\n\t\t\t@printf(\"t = %.6e s \", k*dt)\n\t\t\tprintln(\"(\",round(100*k*dt/t_end),\"% complete)\")\n\t\t\tsave_frame!(out, sys, :P, :v, :type)\n\t\tend\n\t\tapply!(sys, accelerate!)\n\tend\n\tsave_pvd_file(out)\n\tcompute_fluxes(sys)\n\tmake_plot()\nend","category":"page"},{"location":"examples/cavity_flow.html#Functions-to-extract-results-and-create-plots.","page":"Lid-driven cavity","title":"Functions to extract results and create plots.","text":"","category":"section"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"function compute_fluxes(sys::ParticleSystem, res = 100)\n    s = range(0.,1.,length=res)\n    v1 = zeros(res)\n    v2 = zeros(res)\n    for i in 1:res\n\t\t#x-velocity along y-centerline\n\t\tx = RealVector(0.5, s[i], 0.)\n\t\tgamma = SmoothedParticles.sum(sys, (p,r) -> Float64(p.type==FLUID)*m*wendland2(h,r), x)\n        v1[i] = SmoothedParticles.sum(sys, (p,r) -> Float64(p.type==FLUID)*m*p.v[1]*wendland2(h,r), x)/gamma\n\t\t#y-velocity along x-centerline\n\t\tx = RealVector(s[i], 0.5, 0.)\n\t\tgamma = SmoothedParticles.sum(sys, (p,r) -> Float64(p.type==FLUID)*m*wendland2(h,r), x)\n        v2[i] = SmoothedParticles.sum(sys, (p,r) -> Float64(p.type==FLUID)*m*p.v[2]*wendland2(h,r), x)/gamma\n    end\n    #save results into csv\n    data = DataFrame(s=s, v1=v1, v2=v2)\n\tCSV.write(path*\"/data.csv\", data)\n\tmake_plot()\nend\n\nfunction make_plot(Re=Re)\n\tref_x2vy = CSV.read(\"reference/ldc-x2vy.csv\", DataFrame)\n\tref_y2vx = CSV.read(\"reference/ldc-y2vx.csv\", DataFrame)\n\tpropertyname = Symbol(\"Re\", Re)\n\tref_vy = getproperty(ref_x2vy, propertyname)\n\tref_vx = getproperty(ref_y2vx, propertyname)\n\tref_x = ref_x2vy.x\n\tref_y = ref_y2vx.y\n\tdata = CSV.read(path*\"/data.csv\", DataFrame)\n\tp1 = plot(\n\t\tdata.s, data.v2,\n\t\txlabel = L\"x\",\n\t\tylabel = L\"v_y\",\n\t\tlabel = \"SPH\",\n\t\tlinewidth = 4,\n\t\tlegend = :bottomleft,\n\t\tcolor = :orange,\n\t\ttickfontsize = 16,\n\t\tlabelfontsize = 16,\n\t\tlegendfontsize = 16,\n\t\taspect_ratio = 1,\n\t)\n\tscatter!(p1, ref_x, ref_vy, label = \"REF\", markershape = :diamond, ms = 5, color = :blue)\n\tsavefig(p1, path*\"/ldc-x2vy.pdf\")\n\tp2 = plot(\n\t\tdata.v1, data.s,\n\t\txlabel = L\"v_x\",\n\t\tylabel = L\"y\",\n\t\tlabel = \"SPH\",\n\t\tlinewidth = 4,\n\t\tlegend = :bottomright,\n\t\tcolor = :orange,\n\t\ttickfontsize = 16,\n\t\tlabelfontsize = 16,\n\t\tlegendfontsize = 16,\n\t\taspect_ratio = 1,\n\t)\n\tscatter!(p2, ref_vx, ref_y,  label = \"REF\", markershape = :diamond, ms = 5, color = :blue)\n\tsavefig(p2, path*\"/ldc-y2vx.pdf\")\nend\n\nend","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"page"},{"location":"examples/cavity_flow.html","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
